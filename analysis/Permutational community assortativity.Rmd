---
title: "Permutational community assortativity"
author: '"LMM", "AA"'
date: "10 de febrero de 2018"
output: html_document
---

#1. Basics

```{r packages & scripts}
library(igraph)
library(disparityfilter)
library(cowplot)
library(linkcomm)
library(intergraph)
library(GGally)
library(ggrepel)
library(viridis)
library(ggnetwork)
library(vegan)
source("cmbDFrame.R")
source("backbone2.R")
#source("CVsplit.R")
source("strenght_distribution.R")
source("non_nested_height2.R")
source("plotLinkCommMembers2.R")
source("plotLinkCommGraph2.R")
source("Permutational community assortativity.R")
#devtools::install_github("thomasp85/patchwork", force=T)
#library(patchwork) #this replaces cowplot
```

#2. Raw data

```{r Data}
rawnet <- read.csv("master_coral_dis_net.csv",sep=",",na.strings="",header=T, stringsAsFactors = F)
coral.att <- read.csv("glossary.csv")
```

```{r, underscore to spaces}
rawnet <- data.frame(lapply(rawnet, function(x) {
  gsub("_", " ", x)
  }
  ), stringsAsFactors = F)

coral.att <- data.frame(lapply(coral.att, function(x) {
  gsub("_", " ", x)
  }
  ), stringsAsFactors = F)
```




#4. Coral diseases network

La funcion coral.merge y coral.edges toman la matriz de enlaces por filas y la reordenan por combinaciones de dos elementos para dejar una tabla de enlaces

```{r Edges list}
coral.merge <- cmbDFrame(rawnet[,-c(1:4)])
coral.edges <- as.data.frame(coral.merge$mrgCCombs)
```

Ahora construimos la red y le definimos el atributo peso. Como el grafo no es simple, cada enlace tiene peso w = 1 y al simplificarlos, los pesos se suman

```{r Main network}
coral.graph <- graph.data.frame(coral.edges,directed = F)
E(coral.graph)$weight <- rep(1,ecount(coral.graph))
coral.graph <- simplify(coral.graph,
                     edge.attr.comb=list(name="ignore",weight="sum"))
is.simple(coral.graph)
print(coral.graph)
```

##Verificacion

```{r con respecto a red}
#nodos de la red que no estan en la lista de atributos
names(V(coral.graph))[!(tolower(names(V(coral.graph))) %in% tolower(as.character(coral.att$node)))]

#nodos de la lista de atributos que no estan en la red
tolower(as.character(coral.att$node))[!(tolower(as.character(coral.att$node)) %in% tolower(names(V(coral.graph))))]

length(unique(tolower(as.character(coral.att$node)))) ## Hay 297 nodos en total segun el glosario
length(unique(tolower(names(V(coral.graph))))) ## Segun la red, hay 293 nodos en total

## 4 nodos repetidos en la red, estan escritos alguna vez con mayusculas y otras con minusculas
tolower(names(V(coral.graph)))[duplicated(tolower(names(V(coral.graph))))] 

```

##Addition of attributes

```{r attributes}
glossary2 <- coral.att
glossary2$node <- names(V(coral.graph))
coral.att$node <- as.character(coral.att$node)
for (i in 1:nrow(coral.att)) {
  glossary2$attribute[i] <- coral.att$attribute[glossary2$node[i] == tolower(coral.att$node)] 
}
V(coral.graph)$type <- glossary2$attribute
```

##Backbone network

Este segmento origina la columna de la red 

```{r Backbone network}
coral.backbone <- graph.data.frame(backbone2(coral.graph), 
                                   directed = F)
coral.backbone <- decompose.graph(coral.backbone)[[1]]
is_simple(coral.backbone)
coral.backbone <- simplify(coral.backbone, remove.multiple = T)
```

#Link communities assortativity

Matrix Pij and observed link communities for assortativity calculations

```{r}
Pij_comm <- calc_Pmatrix(coral.backbone, 100)
```


```{r}
source("rcomm_exx.R")
source("new_exy_calculation.R")
Exx <- rcomm_exx(Pij_comm)
Exy <- rcom_exy()

rcom <- (Exx - Exy)/(1 - Exy)
```

