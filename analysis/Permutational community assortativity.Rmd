---
title: "Permutational community assortativity"
author: '"LMM", "AA"'
date: "10 de febrero de 2018"
output: html_document
---

#1. Basics

```{r packages & scripts}
library(igraph)
library(disparityfilter)
library(linkcomm)
source("../R/cmbDFrame.R")
source("../R/backbone2.R")
source("../R/strenght_distribution.R")
source("../R/non_nested_height2.R")
source("../R/Permutational_community_assortativity.R") # Por alguna razón hay un desperfecto en como el markdown en mi computadora está haciendo el source a las funciones. Hay que buscar una solución a esto.
```

#2. Raw data

```{r Data}
rawnet <- read.csv("../data/master_codirnet.csv",sep=",",na.strings="",header=T, stringsAsFactors = F)
coral.att <- read.csv("../data/glossary_codirnet.csv")
```

```{r, underscore to spaces}
rawnet <- data.frame(lapply(rawnet, function(x) {
  gsub("_", " ", x)
  }
  ), stringsAsFactors = F)

coral.att <- data.frame(lapply(coral.att, function(x) {
  gsub("_", " ", x)
  }
  ), stringsAsFactors = F)
```




#4. Coral diseases network

La funcion coral.merge y coral.edges toman la matriz de enlaces por filas y la reordenan por combinaciones de dos elementos para dejar una tabla de enlaces

```{r Edges list}
coral.merge <- cmbDFrame(rawnet[,-c(1:4)])
coral.edges <- as.data.frame(coral.merge$mrgCCombs)
```

Ahora construimos la red y le definimos el atributo peso. Como el grafo no es simple, cada enlace tiene peso w = 1 y al simplificarlos, los pesos se suman

```{r Main network}
coral.graph <- graph.data.frame(coral.edges,directed = F)
E(coral.graph)$weight <- rep(1,ecount(coral.graph))
coral.graph <- simplify(coral.graph,
                     edge.attr.comb=list(name="ignore",weight="sum"))
is.simple(coral.graph)
print(coral.graph)
```

##Verificacion

```{r con respecto a red}
#nodos de la red que no estan en la lista de atributos
names(V(coral.graph))[!(tolower(names(V(coral.graph))) %in% tolower(as.character(coral.att$node)))]

#nodos de la lista de atributos que no estan en la red
tolower(as.character(coral.att$node))[!(tolower(as.character(coral.att$node)) %in% tolower(names(V(coral.graph))))]

length(unique(tolower(as.character(coral.att$node)))) ## Hay 297 nodos en total segun el glosario
length(unique(tolower(names(V(coral.graph))))) ## Segun la red, hay 293 nodos en total

## 4 nodos repetidos en la red, estan escritos alguna vez con mayusculas y otras con minusculas
tolower(names(V(coral.graph)))[duplicated(tolower(names(V(coral.graph))))] 

```

##Addition of attributes

```{r attributes}
glossary2 <- coral.att
glossary2$node <- names(V(coral.graph))
coral.att$node <- as.character(coral.att$node)
for (i in 1:nrow(coral.att)) {
  glossary2$attribute[i] <- coral.att$attribute[glossary2$node[i] == tolower(coral.att$node)] 
}
V(coral.graph)$type <- glossary2$attribute
```

##Backbone network

Este segmento origina la columna de la red 

```{r Backbone network}
coral.backbone <- graph.data.frame(backbone2(coral.graph), 
                                   directed = F)
coral.backbone <- decompose.graph(coral.backbone)[[1]]
is_simple(coral.backbone)
coral.backbone <- simplify(coral.backbone, remove.multiple = T)
```

#Link communities assortativity

Matrix Pij and observed link communities for assortativity calculations

```{r message=FALSE, warning=FALSE}
Pij_comm <- calc_Pmatrix(coral.backbone, 100, "linkcomm")
```


```{r}
source("../R/exx_calculation.R")
source("../R/exy_calculation.R")
source("../R/xy_subsets.R")
Exx <- rcomm_exx(Pij_comm)
Exy <- rcomm_exy(Pij_comm)

rcom <- (Exx - Exy)/(1 - Exy)
```

